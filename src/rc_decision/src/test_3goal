#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

class SimpleNavigator : public rclcpp::Node {
public:
    SimpleNavigator(const std::vector<std::string>& args) : Node("simple_navigator") {
        this->client_ptr_ = rclcpp_action::create_client<nav2_msgs::action::NavigateToPose>(this, "navigate_to_pose");
        
        if (args.size() < 4) {
            RCLCPP_ERROR(this->get_logger(), "Usage: cmd x y yaw");
            rclcpp::shutdown();
            exit(1);
        }
        
        x_ = std::stod(args[1]);
        y_ = std::stod(args[2]);
        yaw_ = std::stod(args[3]);
    }

    void send_goal() {
        auto goal_msg = nav2_msgs::action::NavigateToPose::Goal();
        goal_msg.pose.header.frame_id = "map";
        goal_msg.pose.header.stamp = this->get_clock()->now();
        goal_msg.pose.pose.position.x = x_;
        goal_msg.pose.pose.position.y = y_;
        goal_msg.pose.pose.orientation.z = sin(yaw_ / 2.0);
        goal_msg.pose.pose.orientation.w = cos(yaw_ / 2.0);

        if (!this->client_ptr_->wait_for_action_server(std::chrono::seconds(10))) {
            RCLCPP_ERROR(this->get_logger(), "Action server not available after waiting");
            return;
        }

        auto send_goal_options = rclcpp_action::Client<nav2_msgs::action::NavigateToPose>::SendGoalOptions();
        send_goal_options.goal_response_callback =
            [](std::shared_future<rclcpp_action::ClientGoalHandle<nav2_msgs::action::NavigateToPose>::SharedPtr> future) {
                if (!future.get()) {
                    RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Goal was rejected by server");
                } else {
                    RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "Goal accepted by server, waiting for result");
                }
            };

            send_goal_options.result_callback =
            [](const rclcpp_action::ClientGoalHandle<nav2_msgs::action::NavigateToPose>::WrappedResult & result) {
                switch (result.code) {
                    case rclcpp_action::ResultCode::SUCCEEDED:
                        RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "Goal succeeded!");
                        break;
                    case rclcpp_action::ResultCode::ABORTED:
                        RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Goal was aborted");
                        return;
                    case rclcpp_action::ResultCode::CANCELED:
                        RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Goal was canceled");
                        return;
                    default:
                        RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Unknown result code");
                        return;
                }
            };

             this->client_ptr_->async_send_goal(goal_msg, send_goal_options);
    }
private:
    double x_, y_, yaw_;
    rclcpp_action::Client<nav2_msgs::action::NavigateToPose>::SharedPtr client_ptr_;
};

int main(int argc, char ** argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<SimpleNavigator>(std::vector<std::string>(argv + 1, argv + argc));
    node->send_goal();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}